{
  "language": "Solidity",
  "sources": {
    "src/TronicMain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./TronicToken.sol\";\nimport \"./TronicMembership.sol\";\nimport \"./interfaces/IERC6551Account.sol\";\nimport \"lib/tokenbound/lib/openzeppelin-contracts/contracts/proxy/Clones.sol\";\n\ncontract TronicMain {\n    struct MembershipInfo {\n        address membershipAddress;\n        address tokenAddress;\n        string membershipName;\n    }\n\n    enum TokenType {\n        ERC1155,\n        ERC721\n    }\n\n    event MembershipAdded(\n        uint256 indexed membershipId,\n        address indexed membershipAddress,\n        address indexed tokenAddress\n    );\n\n    event MembershipRemoved(uint256 indexed membershipId);\n\n    address public owner;\n    address public tronicAdmin;\n    address payable public tbaAccountImplementation;\n\n    uint8 public maxTiersPerMembership = 10;\n\n    uint256 public membershipCounter;\n    mapping(uint256 => MembershipInfo) private memberships;\n    mapping(address => bool) private _admins;\n\n    // Deployments\n    IERC6551Registry public registry;\n    TronicMembership public tronicMembership;\n    TronicToken public tronicERC1155;\n\n    /// @notice Constructs the TronicMain contract.\n    /// @param _admin The address of the Tronic admin.\n    /// @param _tronicMembership The address of the Tronic Membership contract (ERC721 implementation).\n    /// @param _tronicToken The address of the Tronic Token contract (ERC1155 implementation).\n    /// @param _registry The address of the registry contract.\n    /// @param _tbaImplementation The address of the tokenbound account implementation.\n    constructor(\n        address _admin,\n        address _tronicMembership,\n        address _tronicToken,\n        address _registry,\n        address _tbaImplementation\n    ) {\n        owner = msg.sender;\n        tronicAdmin = _admin;\n        tronicERC1155 = TronicToken(_tronicToken);\n        tronicMembership = TronicMembership(_tronicMembership);\n        registry = IERC6551Registry(_registry);\n        tbaAccountImplementation = payable(_tbaImplementation);\n    }\n\n    /// @notice Checks if the caller is the owner.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    /// @notice Checks if the caller is an admin.\n    modifier onlyAdmin() {\n        require(_admins[msg.sender] || msg.sender == tronicAdmin, \"Only admin\");\n        _;\n    }\n\n    /// @notice Gets MembershipInfo for a given membership ID.\n    /// @param membershipId The ID of the membership to get info for.\n    /// @return The MembershipInfo struct for the given membership ID.\n    /// @dev The membership ID is the index of the membership in the memberships mapping.\n    function getMembershipInfo(uint256 membershipId)\n        external\n        view\n        returns (MembershipInfo memory)\n    {\n        return memberships[membershipId];\n    }\n\n    /// @notice Deploys a new membership's contracts.\n    /// @param membershipName The membership name for the ERC721 token.\n    /// @param membershipSymbol The membership symbol for the ERC721 token.\n    /// @param membershipBaseURI The base URI for the membership ERC721 token.\n    /// @param maxMintable The maximum number of memberships that can be minted.\n    /// @return memberId The ID of the newly created membership.\n    /// @return membershipAddress The address of the deployed membership ERC721 contract.\n    /// @return tokenAddress The address of the deployed token ERC1155 contract.\n    /// @dev The membership ID is the index of the membership in the memberships mapping.\n    function deployMembership(\n        string memory membershipName,\n        string memory membershipSymbol,\n        string memory membershipBaseURI,\n        uint256 maxMintable,\n        bool isElastic,\n        bool isBound\n    )\n        external\n        onlyAdmin\n        returns (uint256 memberId, address membershipAddress, address tokenAddress)\n    {\n        memberId = membershipCounter++;\n\n        // Deploy the membership's contracts\n        membershipAddress = _deployMembership(\n            membershipName, membershipSymbol, membershipBaseURI, maxMintable, isElastic, isBound\n        );\n        tokenAddress = _deployToken();\n\n        // Assign membership id and associate the deployed contracts with the membership\n        memberships[memberId] = MembershipInfo({\n            membershipAddress: membershipAddress,\n            tokenAddress: tokenAddress,\n            membershipName: membershipName\n        });\n\n        emit MembershipAdded(memberId, membershipAddress, tokenAddress);\n    }\n\n    /// @notice Clones the Tronic Membership (ERC721) implementation and initializes it.\n    /// @param name The name of the token.\n    /// @param symbol The symbol of the token.\n    /// @param uri The URI for the cloned contract.\n    /// @return membershipAddress The address of the newly cloned Membership contract.\n    function _deployMembership(\n        string memory name,\n        string memory symbol,\n        string memory uri,\n        uint256 maxSupply,\n        bool isElastic,\n        bool isBound\n    ) private returns (address membershipAddress) {\n        membershipAddress = Clones.clone(address(tronicMembership));\n        TronicMembership(membershipAddress).initialize(\n            tbaAccountImplementation,\n            address(registry),\n            name,\n            symbol,\n            uri,\n            maxTiersPerMembership,\n            maxSupply,\n            isElastic,\n            isBound,\n            tronicAdmin\n        );\n    }\n\n    /// @notice Clones the ERC1155 implementation and initializes it.\n    /// @return tokenAddress The address of the newly cloned ERC1155 contract.\n    function _deployToken() private returns (address tokenAddress) {\n        tokenAddress = Clones.clone(address(tronicERC1155));\n        TronicToken(tokenAddress).initialize(tronicAdmin);\n    }\n\n    /// @notice Removes a membership from the contract.\n    /// @param _membershipId The ID of the membership to remove.\n    function removeMembership(uint256 _membershipId) external onlyAdmin {\n        delete memberships[_membershipId];\n    }\n\n    /// @notice Creates a new ERC1155 fungible token type for a membership.\n    /// @param maxSupply The maximum supply of the token type.\n    /// @param uri The URI for the token type.\n    /// @param membershipId The ID of the membership to create the token type for.\n    /// @return typeId The ID of the newly created token type.\n    function createFungibleTokenType(uint256 maxSupply, string memory uri, uint256 membershipId)\n        external\n        onlyAdmin\n        returns (uint256 typeId)\n    {\n        MembershipInfo memory membership = memberships[membershipId];\n        require(membership.tokenAddress != address(0), \"Membership does not exist\");\n        typeId = TronicToken(membership.tokenAddress).createFungibleType(uint64(maxSupply), uri);\n    }\n\n    /// @notice Creates a new ERC1155 non-fungible token type for a membership.\n    /// @param baseUri The URI for the token type.\n    /// @param maxMintable The maximum number of tokens that can be minted.\n    /// @param membershipId The ID of the membership to create the token type for.\n    /// @return nftTypeID The ID of the newly created token type.\n    function createNonFungibleTokenType(\n        string memory baseUri,\n        uint64 maxMintable,\n        uint256 membershipId\n    ) external onlyAdmin returns (uint256 nftTypeID) {\n        MembershipInfo memory membership = memberships[membershipId];\n        require(membership.tokenAddress != address(0), \"Membership does not exist\");\n        nftTypeID = TronicToken(membership.tokenAddress).createNFTType(baseUri, maxMintable);\n    }\n\n    /// @notice Mints a new ERC721 token for a specified membership.\n    /// @param _recipient The address to mint the token to.\n    /// @param _membershipId The ID of the membership to mint the token for.\n    /// @return The address of the newly created token account.\n    function mintMembership(address _recipient, uint256 _membershipId)\n        external\n        onlyAdmin\n        returns (address payable)\n    {\n        MembershipInfo memory membership = memberships[_membershipId];\n        require(membership.membershipAddress != address(0), \"Membership does not exist\");\n        return TronicMembership(membership.membershipAddress).mint(_recipient);\n    }\n\n    /// @notice Mints a fungible ERC1155 token.\n    /// @param _membershipId The ID of the membership to mint the token for.\n    /// @param _recipient The address to mint the token to.\n    /// @param _tokenId The tokenID (same as typeID for fungibles) of the token to mint.\n    /// @param _amount The amount of the token to mint.\n    function mintFungibleToken(\n        uint256 _membershipId,\n        address _recipient,\n        uint256 _tokenId,\n        uint64 _amount\n    ) external onlyAdmin {\n        MembershipInfo memory membership = memberships[_membershipId];\n        require(membership.tokenAddress != address(0), \"Membership does not exist\");\n        TronicToken(membership.tokenAddress).mintFungible(_recipient, _tokenId, _amount);\n    }\n\n    /// @notice Mints a new nonfungible ERC1155 token.\n    /// @param _membershipId The ID of the membership to mint the token for.\n    /// @param _recipient The address to mint the token to.\n    /// @param _typeId The typeID of the token to mint.\n    /// @param _amount The amount of the token to mint.\n    function mintNonFungibleToken(\n        uint256 _membershipId,\n        address _recipient,\n        uint256 _typeId,\n        uint256 _amount\n    ) external onlyAdmin {\n        MembershipInfo memory membership = memberships[_membershipId];\n        require(membership.tokenAddress != address(0), \"Membership does not exist\");\n        TronicToken(membership.tokenAddress).mintNFTs(_typeId, _recipient, _amount);\n    }\n\n    /// @notice Processes multiple minting operations for both ERC1155 and ERC721 tokens on behalf of memberships.\n    /// @param _membershipIds   Array of membership IDs corresponding to each minting operation.\n    /// @param _recipients   2D array of recipient addresses for each minting operation.\n    /// @param _tokenTypeIDs     4D array of token TypeIDs to mint for each membership.\n    ///                      For ERC1155, it could be multiple IDs, and for ERC721, it should contain a single ID.\n    /// @param _amounts      4D array of token amounts to mint for each membership.\n    ///                      For ERC1155, it represents the quantities of each token ID, and for ERC721, it should be either [1] (to mint) or [0] (to skip).\n    /// @param _contractTypes   3D array specifying the type of each token contract (either ERC1155 or ERC721) to determine the minting logic.\n    /// @dev Requires that all input arrays have matching lengths.\n    ///      For ERC721 minting, the inner arrays of _tokenTypes and _amounts should have a length of 1.\n    /// @dev array indexes: _tokenTypeIDs[membershipId][recipient][contractType][tokenTypeIDs]\n    /// @dev array indexes: _amounts[membershipId][recipient][contractType][amounts]\n    function batchProcess(\n        uint256[] memory _membershipIds,\n        address[][] memory _recipients,\n        uint256[][][][] memory _tokenTypeIDs,\n        uint256[][][][] memory _amounts,\n        TokenType[][][] memory _contractTypes\n    ) external onlyAdmin {\n        require(\n            _membershipIds.length == _tokenTypeIDs.length && _tokenTypeIDs.length == _amounts.length\n                && _amounts.length == _recipients.length && _recipients.length == _contractTypes.length,\n            \"Outer arrays must have the same length\"\n        );\n\n        // i = membershipId, j = recipient, k = contracttype\n        // Loop through each membership\n        for (uint256 i = 0; i < _membershipIds.length; i++) {\n            MembershipInfo memory membership = memberships[_membershipIds[i]];\n\n            for (uint256 j = 0; j < _recipients[i].length; j++) {\n                address recipient = _recipients[i][j];\n\n                for (uint256 k = 0; k < _contractTypes[i][j].length; k++) {\n                    if (_contractTypes[i][j][k] == TokenType.ERC1155) {\n                        TronicToken(membership.tokenAddress).mintBatch(\n                            recipient, _tokenTypeIDs[i][j][k], _amounts[i][j][k], \"\"\n                        );\n                    } else if (_contractTypes[i][j][k] == TokenType.ERC721) {\n                        TronicMembership(membership.membershipAddress).mint(recipient);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice transfers tokens from a membership TBA to a specified address\n    /// @param _tronicTokenId The ID of the tronic token that owns the Tronic TBA\n    /// @param _membershipId The ID of the membership that issued the membership TBA\n    /// @param _membershipTokenId The ID of the membership TBA\n    /// @param _to The address to transfer the tokens to\n    /// @param _transferTokenId The ID of the token to transfer\n    /// @param _amount The amount of tokens to transfer\n    /// @dev This contract address must be granted permissions to transfer tokens from the membership TBA\n    /// @dev The membership TBA must be owned by the Tronic tokenId TBA\n    /// @dev This function is only callable by the tronic admin or an authorized account\n    function transferTokensFromMembershipTBA(\n        uint256 _tronicTokenId,\n        uint256 _membershipId,\n        uint256 _membershipTokenId,\n        address _to,\n        uint256 _transferTokenId,\n        uint256 _amount\n    ) external {\n        // get Tronic TBA address for tronic token id\n        address payable tronicTbaAddress = payable(tronicMembership.getTBAccount(_tronicTokenId));\n        IERC6551Account tronicTBA = IERC6551Account(tronicTbaAddress);\n\n        //ensure caller is tronic admin or authorized to transfer tokens\n        require(\n            tronicTBA.isAuthorized(msg.sender) || _admins[msg.sender] || msg.sender == tronicAdmin,\n            \"Unauthorized caller\"\n        );\n\n        // get membership info\n        MembershipInfo memory membership = memberships[_membershipId];\n        require(membership.tokenAddress != address(0), \"Membership does not exist\");\n\n        // get Membership TBA address\n        address membershipTbaAddress =\n            TronicMembership(membership.membershipAddress).getTBAccount(_membershipTokenId);\n\n        // construct SafeTransferCall for membership ERC1155\n        bytes memory tokenTransferCall = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n            membershipTbaAddress,\n            _to,\n            _transferTokenId,\n            _amount,\n            \"\"\n        );\n\n        // construct execute call for membership tbaAddress to execute tokenTransferCall\n        bytes memory executeCall = abi.encodeWithSignature(\n            \"executeCall(address,uint256,bytes)\", membership.tokenAddress, 0, tokenTransferCall\n        );\n\n        tronicTBA.executeCall(membershipTbaAddress, 0, executeCall);\n    }\n\n    /// @notice transfers tokens from a tronic TBA to a specified address\n    /// @param _tronicTokenId The ID of the tronic token that owns the Tronic TBA\n    /// @param _transferTokenId The ID of the token to transfer\n    /// @param _amount The amount of tokens to transfer\n    /// @param _to The address to transfer the tokens to\n    /// @dev This contract address must be granted permissions to transfer tokens from the Tronic token TBA\n    /// @dev The tronic TBA must be owned by the Tronic tokenId TBA\n    /// @dev This function is only callable by the tronic admin or an authorized account\n    function transferTokensFromTronicTBA(\n        uint256 _tronicTokenId,\n        uint256 _transferTokenId,\n        uint256 _amount,\n        address _to\n    ) external {\n        // get Tronic TBA address for tronic token id\n        address payable tronicTbaAddress = payable(tronicMembership.getTBAccount(_tronicTokenId));\n        IERC6551Account tronicTBA = IERC6551Account(tronicTbaAddress);\n\n        //ensure caller is tronic admin or authorized to transfer tokens\n        require(\n            tronicTBA.isAuthorized(msg.sender) || _admins[msg.sender] || msg.sender == tronicAdmin,\n            \"Unauthorized caller\"\n        );\n\n        // construct SafeTransferCall for tronic ERC1155\n        bytes memory tokenTransferCall = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n            tronicTbaAddress,\n            _to,\n            _transferTokenId,\n            _amount,\n            \"\"\n        );\n\n        tronicTBA.executeCall(address(tronicERC1155), 0, tokenTransferCall);\n    }\n\n    /// @notice transfers membership from a tronic TBA to a specified address\n    /// @param _tronicTokenId The ID of the tronic token that owns the Tronic TBA\n    /// @param _membershipId The ID of the membership that issued the membership TBA\n    /// @param _membershipTokenId The ID of the membership TBA\n    /// @param _to The address to transfer the membership to\n    /// @dev This contract address must be granted permissions to transfer tokens from the Tronic token TBA\n    /// @dev The membership token TBA must be owned by the Tronic token TBA\n    function transferMembershipFromTronicTBA(\n        uint256 _tronicTokenId,\n        uint256 _membershipId,\n        uint256 _membershipTokenId,\n        address _to\n    ) external {\n        // get Tronic TBA address for tronic token id\n        address payable tronicTbaAddress = payable(tronicMembership.getTBAccount(_tronicTokenId));\n        IERC6551Account tronicTBA = IERC6551Account(tronicTbaAddress);\n        //ensure caller is either admin or authorized to transfer tokens\n        require(\n            tronicTBA.isAuthorized(msg.sender) || _admins[msg.sender] || msg.sender == tronicAdmin,\n            \"Unauthorized caller\"\n        );\n\n        // get membership contract address\n        address membershipAddress = memberships[_membershipId].membershipAddress;\n        require(membershipAddress != address(0), \"Membership does not exist\");\n\n        // construct and execute SafeTransferCall for membership ERC721\n        bytes memory membershipTransferCall = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256)\", tronicTbaAddress, _to, _membershipTokenId\n        );\n\n        tronicTBA.executeCall(membershipAddress, 0, membershipTransferCall);\n    }\n\n    /// @notice Sets the ERC721 implementation address, callable only by the owner.\n    /// @param newImplementation The address of the new ERC721 implementation.\n    function setERC721Implementation(address newImplementation) external onlyOwner {\n        tronicMembership = TronicMembership(newImplementation);\n    }\n\n    /// @notice Sets the ERC1155 implementation address, callable only by the owner.\n    /// @param newImplementation The address of the new ERC1155 implementation.\n    function setERC1155Implementation(address newImplementation) external onlyOwner {\n        tronicERC1155 = TronicToken(newImplementation);\n    }\n\n    /// @notice Sets the account implementation address, callable only by the owner.\n    /// @param newImplementation The address of the new account implementation.\n    function setAccountImplementation(address payable newImplementation) external onlyOwner {\n        tbaAccountImplementation = newImplementation;\n    }\n\n    /// @notice Sets the registry address, callable only by the owner.\n    /// @param newRegistry The address of the new registry.\n    function setRegistry(address newRegistry) external onlyOwner {\n        registry = IERC6551Registry(newRegistry);\n    }\n\n    /// @notice Adds an admin to the contract.\n    /// @param admin The address of the new admin.\n    function addAdmin(address admin) external onlyOwner {\n        _admins[admin] = true;\n    }\n\n    /// @notice Removes an admin from the contract.\n    /// @param admin The address of the admin to remove.\n    function removeAdmin(address admin) external onlyOwner {\n        _admins[admin] = false;\n    }\n\n    /// @notice Checks if an address is an admin of the contract.\n    /// @param admin The address to check.\n    /// @return True if the address is an admin, false otherwise.\n    function isAdmin(address admin) external view returns (bool) {\n        return _admins[admin] || admin == tronicAdmin;\n    }\n}\n"
    },
    "src/TronicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"lib/tokenbound/lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol\";\nimport \"lib/tokenbound/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\";\nimport {Strings} from \"lib/tokenbound/lib/openzeppelin-contracts/contracts/utils/Strings.sol\";\n\n/// @title TronicToken\n/// @notice This contract represents the fungible and non-fungible tokens (NFTs) for the Tronic ecosystem.\n/// @dev This contract is based on the ERC1155 standard.\n/// @dev This contract is cloneable.\ncontract TronicToken is ERC1155, Initializable {\n    using Strings for uint256;\n\n    struct FungibleTokenInfo {\n        uint64 maxSupply;\n        uint64 totalMinted;\n        uint64 totalBurned;\n        string uri;\n    }\n\n    struct NFTokenInfo {\n        uint64 startingTokenId;\n        uint64 totalMinted;\n        uint64 maxMintable;\n        string baseURI;\n    }\n\n    event FungibleTokenTypeCreated(uint256 indexed typeId, uint64 maxSupply, string uri);\n\n    event NFTokenTypeCreated(uint256 indexed typeId, uint64 maxMintable, string baseURI);\n\n    uint32 private _tokenTypeCounter;\n    uint64 private _nextNFTTypeStartId = 100_000;\n    address public owner;\n    string public name;\n    string public symbol;\n    mapping(uint256 => FungibleTokenInfo) private _fungibleTokens;\n    mapping(uint256 => NFTokenInfo) private _nftTypes;\n    mapping(uint256 => uint256) public tokenLevels;\n    mapping(uint256 => address) public nftOwners;\n    mapping(address => bool) private _admins;\n\n    // Token ID => URI mapping for fungible tokens\n    mapping(uint256 => string) private _fungibleTokenURIs;\n\n    /// @notice Constructor initializes ERC1155 with an empty URI.\n    constructor() ERC1155(\"\") {}\n\n    /// @dev Modifier to ensure only the owner can call certain functions.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    /// @dev Modifier to ensure only an admin can call certain functions.\n    modifier onlyAdmin() {\n        require(_admins[msg.sender], \"Only Admin\");\n        _;\n    }\n\n    /// @notice Initializes the contract with tronic Admin address.\n    /// @param _tronicAdmin Address of the Tronic admin.\n    /// @dev This function is called by the TronicMain contract.\n    function initialize(address _tronicAdmin) external initializer {\n        owner = _tronicAdmin;\n        _admins[_tronicAdmin] = true;\n        //sets TronicAdmin.sol as admin\n        _admins[msg.sender] = true;\n    }\n\n    /// @notice Gets the information of a fungible token type.\n    /// @param typeId The ID of the token type.\n    /// @return The information of the token type.\n    function getFungibleTokenInfo(uint256 typeId)\n        external\n        view\n        returns (FungibleTokenInfo memory)\n    {\n        return _fungibleTokens[typeId];\n    }\n\n    /// @notice Gets the information of a non-fungible token (NFT) type.\n    /// @param typeId The ID of the token type.\n    /// @return The information of the token type.\n    function getNFTokenInfo(uint256 typeId) external view returns (NFTokenInfo memory) {\n        return _nftTypes[typeId];\n    }\n\n    /// @notice Creates a new non-fungible token (NFT) type.\n    /// @param baseURI Base URI for the token metadata.\n    /// @param maxMintable Max mintable for the NFT type.\n    /// @return nftTypeId The ID of the new NFT type.\n    /// @dev Only callable by admin.\n    /// @dev Requires that the max mintable is greater than 0.\n    function createNFTType(string memory baseURI, uint64 maxMintable)\n        external\n        onlyAdmin\n        returns (uint256 nftTypeId)\n    {\n        nftTypeId = _tokenTypeCounter++;\n        require(_nftTypes[nftTypeId].maxMintable == 0, \"Token type already exists\");\n        require(maxMintable > 0, \"Max mintable must be greater than 0\");\n\n        _nftTypes[nftTypeId] = NFTokenInfo({\n            baseURI: baseURI,\n            startingTokenId: _nextNFTTypeStartId += maxMintable,\n            totalMinted: 0,\n            maxMintable: maxMintable\n        });\n\n        emit NFTokenTypeCreated(nftTypeId, maxMintable, baseURI);\n    }\n\n    /// @notice Creates a new fungible token type.\n    /// @param _maxSupply Max supply for the fungible token type.\n    /// @param _uri URI for the token type's metadata.\n    /// @return fungibleTokenId The ID of the new fungible token type.\n    /// @dev Only callable by admin.\n    /// @dev Requires that the max supply is greater than 0.\n    function createFungibleType(uint64 _maxSupply, string memory _uri)\n        external\n        onlyAdmin\n        returns (uint256 fungibleTokenId)\n    {\n        require(_maxSupply > 0, \"Max supply must be greater than 0\");\n        // Increment the fungible token ID counter and set fungibleTokenId.\n        fungibleTokenId = _tokenTypeCounter++;\n        // Set Fungible Tokens struct for the new token ID.\n        _fungibleTokens[fungibleTokenId] =\n            FungibleTokenInfo({uri: _uri, maxSupply: _maxSupply, totalMinted: 0, totalBurned: 0});\n\n        emit FungibleTokenTypeCreated(fungibleTokenId, _maxSupply, _uri);\n    }\n\n    /// @notice Mints fungible tokens to a specific address.\n    /// @param to Address to mint the tokens to.\n    /// @param id ID of the fungible token type.\n    /// @param amount The amount of tokens to mint.\n    /// @dev Requires that the token type exists and minting amount does not exceed max supply.\n    function mintFungible(address to, uint256 id, uint64 amount) external onlyAdmin {\n        FungibleTokenInfo memory token = _fungibleTokens[id];\n        require(bytes(token.uri).length > 0, \"Token type does not exist\");\n\n        // Increase the totalMinted count\n        token.totalMinted += amount;\n        require(token.totalMinted <= token.maxSupply, \"Exceeds max supply\");\n\n        //update the struct\n        _fungibleTokens[id] = token;\n\n        _mint(to, id, amount, \"\");\n    }\n\n    /// @notice Mints a non-fungible token (NFT) to a specific address.\n    /// @param typeId Type ID of the NFT.\n    /// @param to Address to mint the NFT to.\n    /// @dev Requires that the NFT type already exists.\n    /// @dev Requires that the amount does not exceed the max mintable for the NFT type.\n    function mintNFT(uint256 typeId, address to) external onlyAdmin {\n        //get memory instance of NFT type\n        NFTokenInfo memory nftType = _nftTypes[typeId];\n\n        require(nftType.maxMintable > 0, \"NFT type does not exist\");\n        // Get the next token ID to mint, and increment the totalMinted count\n        uint256 tokenId = getNextTokenIdForType(typeId);\n        require(\n            tokenId <= nftType.startingTokenId + nftType.maxMintable,\n            \"Exceeds max mintable for this NFT type\"\n        );\n\n        nftOwners[tokenId] = to; // Update the owner of the NFT\n\n        // update the struct with new totalMinted\n        _nftTypes[typeId] = nftType;\n\n        _mint(to, tokenId, 1, \"\");\n    }\n\n    /// @notice Mints multiple non-fungible tokens (NFTs) to a specific address.\n    /// @param typeId Type ID of the NFT.\n    /// @param to Address to mint the NFTs to.\n    /// @param amount The amount of NFTs to mint.\n    /// @dev Requires that the NFT type already exists.\n    /// @dev Requires that the amount does not exceed the max mintable for the NFT type.\n    /// @dev only callable by admin\n    function mintNFTs(uint256 typeId, address to, uint256 amount) external onlyAdmin {\n        _mintNFTs(typeId, to, amount);\n    }\n\n    /// @notice Mints multiple non-fungible tokens (NFTs) to a specific address.\n    /// @param typeId Type ID of the NFT.\n    /// @param to Address to mint the NFTs to.\n    /// @param amount The amount of NFTs to mint.\n    /// @dev Requires that the NFT type already exists.\n    /// @dev Requires that the amount does not exceed the max mintable for the NFT type.\n    function _mintNFTs(uint256 typeId, address to, uint256 amount) internal {\n        //get memory instance of NFT type\n        NFTokenInfo memory nftType = _nftTypes[typeId];\n\n        require(nftType.maxMintable > 0, \"NFT type does not exist\");\n        require(\n            nftType.totalMinted + amount <= nftType.maxMintable,\n            \"Exceeds max mintable for this NFT type\"\n        );\n\n        // Build the token ID and amount arrays for batchMint call\n        uint256[] memory tokenIds = new uint256[](amount);\n        uint256[] memory amounts = new uint256[](amount);\n        uint256 _tokenId = getNextTokenIdForType(typeId);\n\n        for (uint256 i = 0; i < amount; i++) {\n            tokenIds[i] = _tokenId;\n            amounts[i] = 1; // Each NFT token id has an amount of 1\n\n            nftOwners[_tokenId++] = to; // Update the owner of the NFT\n        }\n\n        // update the struct with new totalMinted\n        _nftTypes[typeId].totalMinted += uint64(amount);\n\n        _mintBatch(to, tokenIds, amounts, \"\");\n    }\n\n    /// @notice Sets the level of a specific token ID.\n    /// @param tokenId The ID of the token.\n    /// @param level The level to set.\n    /// @dev Only callable by admin.\n    function setLevel(uint256 tokenId, uint256 level) external onlyAdmin {\n        tokenLevels[tokenId] = level;\n    }\n\n    /// @notice Gets the level of a specific token ID.\n    /// @param tokenId The ID of the token.\n    /// @return The level of the token.\n    function getLevel(uint256 tokenId) external view returns (uint256) {\n        return tokenLevels[tokenId];\n    }\n\n    /// @notice Mints multiple tokens to a specific address.\n    /// @param to Address to mint the tokens to.\n    /// @param typeIds Type IDs of the tokens to mint.\n    /// @param amounts Amounts of each token to mint.\n    /// @param data Additional data to include in the minting call.\n    /// @dev Requires that the token type IDs and amounts arrays have matching lengths.\n    function mintBatch(\n        address to,\n        uint256[] memory typeIds,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external onlyAdmin {\n        require(to != address(0), \"ERC1155Cloneable: mint to the zero address\");\n        require(typeIds.length == amounts.length, \"Mismatch between typeIds and amounts length\");\n\n        uint256[] memory idsToMint = new uint256[](typeIds.length);\n\n        for (uint256 i = 0; i < typeIds.length; i++) {\n            // Check if it's a fungible token type\n            if (_fungibleTokens[typeIds[i]].maxSupply > 0) {\n                require(\n                    _fungibleTokens[typeIds[i]].totalMinted + amounts[i]\n                        <= _fungibleTokens[typeIds[i]].maxSupply,\n                    \"Exceeds max supply for some IDs\"\n                );\n\n                // Increase the totalMinted count for fungible tokens\n                _fungibleTokens[typeIds[i]].totalMinted += uint64(amounts[i]);\n\n                idsToMint[i] = typeIds[i];\n            } else if (_nftTypes[typeIds[i]].maxMintable > 0) {\n                _mintNFTs(typeIds[i], to, amounts[i]);\n\n                // set amount to 0 for NFTs so that it doesn't get minted again\n                amounts[i] = 0;\n            } else {\n                revert(\"Token type does not exist for some IDs\");\n            }\n        }\n\n        _mintBatch(to, idsToMint, amounts, data);\n    }\n\n    /// @notice Burns tokens from a specific address.\n    /// @param account Address to burn tokens from.\n    /// @param id ID of the token type to burn.\n    /// @param amount The amount of tokens to burn.\n    function burn(address account, uint256 id, uint256 amount) public onlyAdmin {\n        _burn(account, id, amount);\n    }\n\n    /// @notice Gets the next token ID for a specific token type.\n    /// @param typeId The ID of the token type.\n    /// @return The next token ID for the token type.\n    function getNextTokenIdForType(uint256 typeId) public view returns (uint256) {\n        return _nftTypes[typeId].startingTokenId + _nftTypes[typeId].totalMinted + 1;\n    }\n\n    /// @notice Returns the URI for a specific token ID.\n    /// @param tokenId The ID of the token.\n    /// @return The URI of the token.\n    /// @dev Overrides the base implementation to support fungible tokens.\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        // Check if it's a fungible token type\n        if (bytes(_fungibleTokenURIs[tokenId]).length > 0) {\n            return _fungibleTokenURIs[tokenId];\n        }\n\n        // Check if it's a non-fungible token type\n        for (uint256 typeId = 0; typeId < _tokenTypeCounter; typeId++) {\n            if (\n                tokenId >= _nftTypes[typeId].startingTokenId\n                    && tokenId < _nftTypes[typeId].startingTokenId + _nftTypes[typeId].maxMintable\n            ) {\n                // Construct URI\n                return string(abi.encodePacked(_nftTypes[typeId].baseURI, \"/\", tokenId.toString()));\n            }\n        }\n\n        // If not found in both, revert to the parent implementation\n        return super.uri(tokenId);\n    }\n\n    /// @notice Adds an admin to the contract.\n    /// @param admin The address of the new admin.\n    function addAdmin(address admin) external onlyOwner {\n        _admins[admin] = true;\n    }\n\n    /// @notice Removes an admin from the contract.\n    /// @param admin The address of the admin to remove.\n    function removeAdmin(address admin) external onlyOwner {\n        _admins[admin] = false;\n    }\n\n    /// @notice Checks if an address is an admin of the contract.\n    /// @param admin The address to check.\n    /// @return True if the address is an admin, false otherwise.\n    function isAdmin(address admin) external view returns (bool) {\n        return _admins[admin];\n    }\n\n    /// @notice Checks if the contract supports a specific interface.\n    /// @param interfaceId The interface ID to check for.\n    /// @return True if the interface is supported, false otherwise.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC1155).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/TronicMembership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IERC6551Registry.sol\";\nimport \"lib/tokenbound/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\";\nimport \"lib/tokenbound/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\";\n\n/// @title TronicMembership\n/// @notice This contract represents the membership token for the Tronic ecosystem.\ncontract TronicMembership is ERC721, Initializable {\n    /// @dev Struct representing a membership tier.\n    /// @param tierId The ID of the tier.\n    /// @param duration The duration of the tier in seconds.\n    /// @param isOpen Whether the tier is open or closed.\n    struct MembershipTier {\n        string tierId;\n        uint128 duration;\n        bool isOpen;\n    }\n\n    /// @dev Struct representing the membership details of a token.\n    /// @param tierIndex The index of the membership tier.\n    /// @param timestamp The timestamp of the membership.\n    struct TokenMembership {\n        uint8 tierIndex;\n        uint128 timestamp;\n    }\n\n    string private _name;\n    string private _symbol;\n    string private _baseURI_;\n\n    address public owner;\n    address public accountImplementation;\n    uint8 private _numTiers;\n    uint8 private _maxTiers;\n    bool public isElastic;\n    bool public isBound;\n    uint256 public maxSupply;\n    uint256 private _totalBurned;\n    uint256 private _totalMinted;\n\n    IERC6551Registry public registry;\n\n    mapping(uint8 => MembershipTier) private _membershipTiers;\n    mapping(uint256 => TokenMembership) private _tokenMemberships;\n    mapping(address => bool) private _admins;\n\n    /// @dev Modifier to ensure only the owner can call certain functions.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    /// @dev Modifier to ensure only the admin can call certain functions.\n    modifier onlyAdmin() {\n        require(_admins[msg.sender], \"Only admin\");\n        _;\n    }\n\n    /// @dev Modifier to ensure a tier exists.\n    /// @param tierIndex The index of the tier to check.\n    modifier tierExists(uint8 tierIndex) {\n        require(tierIndex <= _numTiers, \"Tier does not exist\");\n        _;\n    }\n\n    /// @dev Modifier to ensure a token exists.\n    /// @param tokenId The ID of the token to check.\n    modifier tokenExists(uint256 tokenId) {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        _;\n    }\n\n    /// @notice Constructor initializes the ERC721 with empty name and symbol.\n    /// @dev The name and symbol can be set using the initialize function.\n    /// @dev The constructor is left empty because of the proxy pattern used.\n    constructor() ERC721(\"\", \"\") {}\n\n    /// @notice Initializes the contract with given parameters.\n    /// @param _accountImplementation Implementation of the account.\n    /// @param _registry Address of the registry contract.\n    /// @param name_ Name of the token.\n    /// @param symbol_ Symbol of the token.\n    /// @param uri Base URI of the token.\n    /// @param _maxMembershipTiers Maximum number of membership tiers.\n    /// @param _maxSupply Maximum supply of the token.\n    /// @param _isElastic Whether the max token supply is elastic or not.\n    /// @param _isBound Whether the token is soulbound or not.\n    /// @param tronicAdmin Address of the initial admin.\n    /// @dev This function is called by the tronicMain contract.\n    function initialize(\n        address payable _accountImplementation,\n        address _registry,\n        string memory name_,\n        string memory symbol_,\n        string memory uri,\n        uint8 _maxMembershipTiers,\n        uint256 _maxSupply,\n        bool _isElastic,\n        bool _isBound,\n        address tronicAdmin\n    ) external initializer {\n        accountImplementation = _accountImplementation;\n        registry = IERC6551Registry(_registry);\n        owner = tronicAdmin;\n        _admins[tronicAdmin] = true;\n        _admins[msg.sender] = true;\n        _name = name_;\n        _symbol = symbol_;\n        _baseURI_ = uri;\n        _maxTiers = _maxMembershipTiers;\n        maxSupply = _maxSupply;\n        isElastic = _isElastic;\n        isBound = _isBound;\n    }\n\n    /// @notice Mints a new token.\n    /// @param to Address to mint the token to.\n    /// @return tbaAccount The payable address of the created tokenbound account.\n    /// @dev The tokenbound account is created using the registry contract.\n    function mint(address to) public onlyAdmin returns (address payable tbaAccount) {\n        require(++_totalMinted <= maxSupply, \"Max supply reached\");\n        // Deploy token account\n        tbaAccount = payable(\n            registry.createAccount(\n                accountImplementation,\n                block.chainid,\n                address(this),\n                _totalMinted,\n                0, // salt\n                abi.encodeWithSignature(\"initialize()\") // init data\n            )\n        );\n\n        // Mint token\n        _mint(to, _totalMinted);\n    }\n\n    /// @notice Creates a new membership tier.\n    /// @param tierId The ID of the new tier.\n    /// @param duration The duration of the new tier in seconds.\n    /// @param isOpen Whether the tier is open or closed.\n    /// @dev Only callable by admin.\n    function createMembershipTier(string memory tierId, uint128 duration, bool isOpen)\n        external\n        onlyAdmin\n    {\n        require(++_numTiers <= _maxTiers, \"Max Tier limit reached\");\n        _membershipTiers[_numTiers] =\n            MembershipTier({tierId: tierId, duration: duration, isOpen: isOpen});\n    }\n\n    /// @notice Creates multiple new membership tiers.\n    /// @param tierIds The IDs of the new tiers.\n    /// @param durations The durations of the new tiers in seconds.\n    /// @param isOpens Whether the tiers are open or closed.\n    /// @dev Only callable by admin. Arrays must all have the same length.\n    function createMembershipTiers(\n        string[] memory tierIds,\n        uint128[] memory durations,\n        bool[] memory isOpens\n    ) external onlyAdmin {\n        require(\n            isOpens.length == tierIds.length && tierIds.length == durations.length,\n            \"Input array mismatch\"\n        );\n        require(_numTiers + tierIds.length <= _maxTiers, \"Max Tier limit reached\");\n\n        for (uint256 i = 0; i < tierIds.length; i++) {\n            _membershipTiers[++_numTiers] =\n                MembershipTier({tierId: tierIds[i], duration: durations[i], isOpen: isOpens[i]});\n        }\n    }\n\n    /// @notice Sets the open status of a membership tier.\n    /// @param tierIndex The index of the tier to update.\n    /// @param isOpen The new open status.\n    /// @dev Only callable by admin.\n    /// @dev the tier must exist.\n    function setMembershipTierOpenStatus(uint8 tierIndex, bool isOpen)\n        external\n        onlyAdmin\n        tierExists(tierIndex)\n    {\n        _membershipTiers[tierIndex].isOpen = isOpen;\n    }\n\n    /// @notice Sets the ID of a membership tier.\n    /// @param tierIndex The index of the tier to update.\n    /// @param tierId The new tier ID.\n    /// @dev Only callable by admin.\n    /// @dev the tier must exist.\n    function setMembershipTierId(uint8 tierIndex, string memory tierId)\n        external\n        onlyAdmin\n        tierExists(tierIndex)\n    {\n        _membershipTiers[tierIndex].tierId = tierId;\n    }\n\n    /// @notice Sets the duration of a membership tier.\n    /// @param tierIndex The index of the tier to update.\n    /// @param duration The new duration in seconds.\n    /// @dev Only callable by admin.\n    /// @dev the tier must exist.\n    function setMembershipTierDuration(uint8 tierIndex, uint128 duration)\n        external\n        onlyAdmin\n        tierExists(tierIndex)\n    {\n        _membershipTiers[tierIndex].duration = duration;\n    }\n\n    /// @notice Retrieves the details of a membership tier.\n    /// @param tierIndex The index of the tier to retrieve.\n    /// @return The details of the tier.\n    function getMembershipTierDetails(uint8 tierIndex)\n        external\n        view\n        returns (MembershipTier memory)\n    {\n        return _membershipTiers[tierIndex];\n    }\n\n    /// @notice Retrieves the ID of a membership tier.\n    /// @param tierIndex The index of the tier to retrieve.\n    /// @return The ID of the tier.\n    function getMembershipTierId(uint8 tierIndex) external view returns (string memory) {\n        return _membershipTiers[tierIndex].tierId;\n    }\n\n    /// @notice Sets the membership details of a specific token.\n    /// @param tokenId The ID of the token whose membership details are to be set.\n    /// @param tierIndex The index of the membership tier to associate with the token.\n    /// @dev This function can only be called by an admin.\n    /// @dev The tier must exist.\n    /// @dev The token must exist.\n    function setTokenMembership(uint256 tokenId, uint8 tierIndex)\n        external\n        onlyAdmin\n        tierExists(tierIndex)\n        tokenExists(tokenId)\n    {\n        _tokenMemberships[tokenId] = TokenMembership(tierIndex, uint128(block.timestamp));\n    }\n\n    /// @notice Retrieves the membership details of a specific token.\n    /// @param tokenId The ID of the token whose membership details are to be retrieved.\n    /// @return The membership details of the token, represented by a `TokenMembership` struct.\n    /// @dev The token must exist.\n    function getTokenMembership(uint256 tokenId)\n        external\n        view\n        tokenExists(tokenId)\n        returns (TokenMembership memory)\n    {\n        return _tokenMemberships[tokenId];\n    }\n\n    /// @notice Retrieves the tokenbound account of a given token ID.\n    /// @param tokenId The ID of the token.\n    /// @return The address of the tokenbound account.\n    function getTBAccount(uint256 tokenId) external view returns (address) {\n        return registry.account(accountImplementation, block.chainid, address(this), tokenId, 0);\n    }\n\n    /// @notice Retrieves tier index of a given tier ID.\n    /// @param tierId The ID of the tier.\n    /// @return The index of the tier.\n    /// @dev Returns 0 if the tier does not exist.\n    function getTierIndexByTierId(string memory tierId) external view returns (uint8) {\n        for (uint8 i = 1; i <= _numTiers; i++) {\n            string memory candidateTierId = _membershipTiers[i].tierId;\n            if (keccak256(abi.encodePacked(candidateTierId)) == keccak256(abi.encodePacked(tierId)))\n            {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    //function to determine if a token has a valid membership\n    /// @notice Checks if a token has a valid membership.\n    /// @param tokenId The ID of the token.\n    /// @return True if the token has a valid membership, false otherwise.\n    /// @dev The token must exist.\n    function isValid(uint256 tokenId) external view tokenExists(tokenId) returns (bool) {\n        TokenMembership memory membership = _tokenMemberships[tokenId];\n        MembershipTier memory tier = _membershipTiers[membership.tierIndex];\n        return membership.timestamp + tier.duration > block.timestamp;\n    }\n\n    /// @notice Burns a token with the given ID.\n    /// @param tokenId ID of the token to burn.\n    function burn(uint256 tokenId) external onlyAdmin {\n        ++_totalBurned;\n        _tokenMemberships[tokenId] = TokenMembership(0, 0);\n        _burn(tokenId);\n    }\n\n    /// @notice Sets the max supply of the token.\n    /// @param _maxSupply The new max supply.\n    /// @dev Only callable by admin.\n    /// @dev Only callable for elastic tokens.\n    /// @dev The max supply must be greater than the total minted.\n    function setMaxSupply(uint256 _maxSupply) external onlyAdmin {\n        require(isElastic, \"Max supply can only be set for elastic tokens\");\n        require(_maxSupply > _totalMinted, \"Max supply must be greater than total minted\");\n        maxSupply = _maxSupply;\n    }\n\n    /// @notice Sets the base URI for the token.\n    /// @param uri The new base URI.\n    function setBaseURI(string memory uri) external onlyOwner {\n        _baseURI_ = uri;\n    }\n\n    /// @notice Returns the name of the token.\n    /// @return The name of the token.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token.\n    /// @return The symbol of the token.\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Adds an admin.\n    /// @param _admin The address of the new admin.\n    /// @dev Only callable by owner.\n    function addAdmin(address _admin) external onlyOwner {\n        _admins[_admin] = true;\n    }\n\n    /// @notice Removes an admin.\n    /// @param _admin The address of the admin to remove.\n    /// @dev Only callable by owner.\n    function removeAdmin(address _admin) external onlyOwner {\n        _admins[_admin] = false;\n    }\n\n    /// @notice Checks if an address is an admin.\n    /// @param _admin The address to check.\n    /// @return True if the address is an admin, false otherwise.\n    function isAdmin(address _admin) external view returns (bool) {\n        return _admins[_admin];\n    }\n\n    /// @notice Updates the implementation of the account.\n    /// @param _accountImplementation The new account implementation address.\n    /// @dev Only callable by owner.\n    function updateImplementation(address payable _accountImplementation) external onlyOwner {\n        accountImplementation = _accountImplementation;\n    }\n\n    /// @notice Overrides the supportsInterface function to include support for ERC721.\n    /// @param interfaceId The interface ID to check for.\n    /// @return True if the interface is supported, false otherwise.\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Transfers ownership of the contract to a new owner.\n    /// @param newOwner The address of the new owner.\n    /// @dev Only callable by owner.\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner address cannot be zero\");\n        owner = newOwner;\n    }\n\n    /// @notice Transfers an unbound token from one address to another.\n    /// @param from The address to transfer the token from.\n    /// @param to The address to transfer the token to.\n    /// @param tokenId The ID of the token to transfer.\n    /// @dev This function overrides the transferFrom function of ERC721.\n    /// @dev it reverts if the token is bound.\n    function transferFrom(address from, address to, uint256 tokenId) public override {\n        require(!isBound, \"Token is bound\");\n        super.transferFrom(from, to, tokenId);\n    }\n\n    /// @notice Safely transfers an unbound token from one address to another.\n    /// @param from The address to transfer the token from.\n    /// @param to The address to transfer the token to.\n    /// @param tokenId The ID of the token to transfer.\n    /// @dev This function overrides the safeTransferFrom function of ERC721.\n    /// @dev it reverts if the token is bound.\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data)\n        public\n        override\n    {\n        require(!isBound, \"Token is bound\");\n        super.safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /// @notice Returns the total supply of the token.\n    /// @return The total supply of the token.\n    function totalSupply() external view returns (uint256) {\n        return _totalMinted - _totalBurned;\n    }\n}\n"
    },
    "src/interfaces/IERC6551Account.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev the ERC-165 identifier for this interface is `0x6faff5f1`\ninterface IERC6551Account {\n    /**\n     * @dev Allows the account to receive Ether\n     *\n     * Accounts MUST implement a `receive` function\n     *\n     * Accounts MAY perform arbitrary logic to restrict conditions\n     * under which Ether can be received\n     */\n    receive() external payable;\n\n    /**\n     * @dev Returns the identifier of the non-fungible token which owns the account\n     *\n     * The return value of this function MUST be constant - it MUST NOT change over time\n     *\n     * @return chainId       The EIP-155 ID of the chain the token exists on\n     * @return tokenContract The contract address of the token\n     * @return tokenId       The ID of the token\n     */\n    function token()\n        external\n        view\n        returns (uint256 chainId, address tokenContract, uint256 tokenId);\n\n    /**\n     * @dev Returns a value that SHOULD be modified each time the account changes state\n     *\n     * @return The current account state\n     */\n    function state() external view returns (uint256);\n\n    /**\n     * @dev Returns a magic value indicating whether a given signer is authorized to act on behalf\n     * of the account\n     *\n     * MUST return the bytes4 magic value 0x523e3260 if the given signer is valid\n     *\n     * By default, the holder of the non-fungible token the account is bound to MUST be considered\n     * a valid signer\n     *\n     * Accounts MAY implement additional authorization logic which invalidates the holder as a\n     * signer or grants signing permissions to other non-holder accounts\n     *\n     * @param  signer     The address to check signing authorization for\n     * @param  context    Additional data used to determine whether the signer is valid\n     * @return magicValue Magic value indicating whether the signer is valid\n     */\n    function isValidSigner(address signer, bytes calldata context)\n        external\n        view\n        returns (bytes4 magicValue);\n\n    function executeCall(address to, uint256 value, bytes calldata data)\n        external\n        payable\n        returns (bytes memory);\n\n    function owner() external view returns (address);\n    function isAuthorized(address caller) external view returns (bool);\n\n    function setPermissions(address[] calldata callers, bool[] calldata _permissions) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/interfaces/IERC6551Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC6551Registry {\n    /**\n     * @dev The registry SHALL emit the AccountCreated event upon successful account creation\n     */\n    event AccountCreated(\n        address account,\n        address indexed implementation,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId,\n        uint256 salt\n    );\n\n    /**\n     * @dev Creates a token bound account for a non-fungible token\n     *\n     * If account has already been created, returns the account address without calling create2\n     *\n     * If initData is not empty and account has not yet been created, calls account with\n     * provided initData after creation\n     *\n     * Emits AccountCreated event\n     *\n     * @return the address of the account\n     */\n    function createAccount(\n        address implementation,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        uint256 seed,\n        bytes calldata initData\n    ) external returns (address);\n\n    /**\n     * @dev Returns the computed token bound account address for a non-fungible token\n     *\n     * @return The computed address of the token bound account\n     */\n    function account(address implementation, uint256 chainId, address tokenContract, uint256 tokenId, uint256 salt)\n        external\n        view\n        returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=lib/tokenbound/lib/openzeppelin-contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "account-abstraction/=lib/tokenbound/lib/account-abstraction/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "erc6551/=lib/tokenbound/lib/reference/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "tokenbound/=lib/tokenbound/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}