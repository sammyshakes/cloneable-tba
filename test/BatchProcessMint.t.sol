// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

import "./TronicTestBase.t.sol";

contract BatchProcessMint is TronicTestBase {
    function testBatchProcess() public {
        // instantiate BatchMintOrder array
        BatchMintOrder[] memory orders = new BatchMintOrder[](2);

        vm.startPrank(tronicAdmin);

        // for membership x: (order1)
        // user1 gets erc721 and fungible erc1155 tokens
        // user2 gets fungible and nonfungible erc1155 tokens

        // for membership y: (order2)
        // user3 gets 2 amounts of fungible erc1155 tokens

        // For order1 (membershipX)
        address[] memory _recipients = new address[](2);
        _recipients[0] = user1;
        _recipients[1] = user2;

        uint256[][][] memory _tokenIds = new uint256[][][](2);
        //user1 gets fungible erc1155 and erc721 tokens from membership x
        _tokenIds[0] = new uint256[][](2); // user 1 gets both contract types

        //erc721 contract type
        _tokenIds[0][0] = new uint256[](1); // gets 1 tokenid for erc721
        _tokenIds[0][0][0] = 0; //erc721 tokenid irrelevant because it is autogenerated for user1, any value works here

        // erc1155 contract type
        _tokenIds[0][1] = new uint256[](1); // gets 1 token id for erc1155
        _tokenIds[0][1][0] = fungibleTypeIdX1; //fungible token id for user1

        //user2 gets fungible and nonfungible tokens from membership x
        //erc1155 token ids for user2
        _tokenIds[1] = new uint256[][](1); // user 2 gets only erc1155 contract type

        _tokenIds[1][0] = new uint256[](2); // user2 gets 2 tokenids for erc1155
        _tokenIds[1][0][0] = fungibleTypeIdX1; // fungible token id for user2
        _tokenIds[1][0][1] = nonFungibleTypeIdX1; // nonfungible token id for user2

        //amounts for each token id
        uint256[][][] memory _amounts = new uint256[][][](2);
        // amount for user1's tokenId irrelevant when calling erc721 contract (always be treated as a 1)
        _amounts[0] = new uint256[][](2);
        _amounts[0][0] = new uint256[](1);
        _amounts[0][0][0] = 1;

        //fungible token amount for user1
        _amounts[0][1] = new uint256[](1);
        _amounts[0][1][0] = 10_000;

        //user2 gets fungible and nonfungible tokens from membership x
        //fungible token amount for user2
        _amounts[1] = new uint256[][](1);
        _amounts[1][0] = new uint256[](2);
        _amounts[1][0][0] = 1000; // amount for user2's erc1155 fungible tokenId
        _amounts[1][0][1] = 1; // amount for user2 erc1155 nonfungible tokenid

        TronicMain.TokenType[][] memory _tokenTypes = new TronicMain.TokenType[][](2);
        _tokenTypes[0] = new TronicMain.TokenType[](2);
        _tokenTypes[0][0] = TronicMain.TokenType.ERC721;
        _tokenTypes[0][1] = TronicMain.TokenType.ERC1155;
        _tokenTypes[1] = new TronicMain.TokenType[](1);
        _tokenTypes[1][0] = TronicMain.TokenType.ERC1155;

        BatchMintOrder memory order1 = createBatchMintOrder(
            membershipIDX, // membershipIdX
            _recipients,
            _tokenIds,
            _amounts,
            _tokenTypes
        );

        // For order2 (membershipY)
        _recipients = new address[](1);
        _recipients[0] = user3;

        _tokenIds = new uint256[][][](1);
        _tokenIds[0] = new uint256[][](1);
        _tokenIds[0][0] = new uint256[](2);

        _tokenIds[0][0][0] = fungibleTypeIdY1; // first tokenId for user3

        _tokenIds[0][0][1] = tronicMainContract.createFungibleTokenType(
            5000, "http://example.com/token/", membershipIDY
        ); // second tokenId for user3

        _amounts = new uint256[][][](1);
        _amounts[0] = new uint256[][](1);
        _amounts[0][0] = new uint256[](2);
        _amounts[0][0][0] = 10; // amount for user3's first tokenId
        _amounts[0][0][1] = 20; // amount for user3's second tokenId

        _tokenTypes = new TronicMain.TokenType[][](1);
        _tokenTypes[0] = new TronicMain.TokenType[](1);
        _tokenTypes[0][0] = TronicMain.TokenType.ERC1155; // type for user3's first and second tokenId

        BatchMintOrder memory order2 = createBatchMintOrder(
            membershipIDY, // membershipIdY
            _recipients,
            _tokenIds,
            _amounts,
            _tokenTypes
        );

        //populate orders array
        orders[0] = order1;
        orders[1] = order2;

        // Prepare data for batchProcess using the helper function
        (
            uint256[] memory membershipIds,
            address[][] memory recipients,
            uint256[][][][] memory tokenIds,
            uint256[][][][] memory amounts,
            TronicMain.TokenType[][][] memory tokenTypes
        ) = prepareBatchProcessData(orders);

        vm.stopPrank();

        vm.startPrank(unauthorizedUser);
        vm.expectRevert();
        // Execute the batchProcess function
        tronicMainContract.batchProcess(membershipIds, recipients, tokenIds, amounts, tokenTypes);

        vm.stopPrank();

        vm.startPrank(tronicAdmin);

        // Execute the batchProcess function
        tronicMainContract.batchProcess(membershipIds, recipients, tokenIds, amounts, tokenTypes);

        // Assertions
        // For membership 1, ERC721
        assertEq(ERC721(clone721AddressX).ownerOf(1), user1);

        // For membership 1, ERC1155
        assertEq(membershipXERC1155.balanceOf(user1, fungibleTypeIdX1), 10_000);
        assertEq(membershipXERC1155.balanceOf(user2, fungibleTypeIdX1), 1000);

        // For membership 2, ERC1155
        assertEq(membershipYERC1155.balanceOf(user3, fungibleTypeIdY1), 10);
        assertEq(membershipYERC1155.balanceOf(user3, _tokenIds[0][0][1]), 20);

        TronicToken.NFTokenInfo memory nonFungibleX1 =
            membershipXERC1155.getNFTokenInfo(nonFungibleTypeIdX1);

        console.log("nonFungibleTypeIdX1 ", nonFungibleTypeIdX1);
        console.log("nonFungibleX1.startingTokenId: ", nonFungibleX1.startingTokenId);
        console.log("nonFungibleX1.maxMintable: ", nonFungibleX1.maxMintable);
        console.log("nonFungibleX1.totalMinted: ", nonFungibleX1.totalMinted);
        console.log("nonFungibleX1.baseURI: ", nonFungibleX1.baseURI);

        assertEq(
            membershipXERC1155.balanceOf(
                user2, nonFungibleX1.startingTokenId + nonFungibleX1.totalMinted
            ),
            1
        );

        assertEq(
            membershipXERC1155.nftOwners(nonFungibleX1.startingTokenId + nonFungibleX1.totalMinted),
            user2
        );

        //test with membership id arrays of mismatched lengths
        uint256[] memory _membershipIds = new uint256[](4);
        _membershipIds[0] = membershipIDX;
        _membershipIds[1] = membershipIDY;
        _membershipIds[2] = membershipIDX;
        _membershipIds[3] = membershipIDY;

        vm.expectRevert();
        tronicMainContract.batchProcess(_membershipIds, recipients, tokenIds, amounts, tokenTypes);

        //test with token id arrays of mismatched lengths
        uint256[][][][] memory _tokenIds2 = new uint256[][][][](1);
        _tokenIds2[0] = new uint256[][][](1);
        _tokenIds2[0][0] = new uint256[][](2);
        _tokenIds2[0][0][0] = new uint256[](1);
        _tokenIds2[0][0][0][0] = 0;
        _tokenIds2[0][0][1] = new uint256[](1);
        _tokenIds2[0][0][1][0] = fungibleTypeIdX1;

        vm.expectRevert();
        tronicMainContract.batchProcess(membershipIds, recipients, _tokenIds2, amounts, tokenTypes);

        //test with amounts arrays of mismatched lengths
        uint256[][][][] memory _amounts2 = new uint256[][][][](1);
        _amounts2[0] = new uint256[][][](1);
        _amounts2[0][0] = new uint256[][](1);
        _amounts2[0][0][0] = new uint256[](1);
        _amounts2[0][0][0][0] = 1;

        vm.expectRevert();
        tronicMainContract.batchProcess(membershipIds, recipients, tokenIds, _amounts2, tokenTypes);

        //test with tokentype arrays of mismatched lengths
        TronicMain.TokenType[][][] memory _tokenTypes2 = new TronicMain.TokenType[][][](1);
        _tokenTypes2[0] = new TronicMain.TokenType[][](1);
        _tokenTypes2[0][0] = new TronicMain.TokenType[](1);
        _tokenTypes2[0][0][0] = TronicMain.TokenType.ERC721;

        vm.expectRevert();
        tronicMainContract.batchProcess(membershipIds, recipients, tokenIds, amounts, _tokenTypes2);

        //test with recipient arrays of mismatched lengths
        address[][] memory _recipients2 = new address[][](1);
        _recipients2[0] = new address[](1);
        _recipients2[0][0] = user1;

        vm.expectRevert();
        tronicMainContract.batchProcess(membershipIds, _recipients2, tokenIds, amounts, tokenTypes);

        vm.stopPrank();
    }
}
